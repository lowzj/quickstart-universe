from abc import ABC, abstractmethod
from pydantic import BaseModel, HttpUrl, Field
from typing import List, Optional, Dict, Any
import logging  # Added for MockContentExtractor

# Setup basic logging configuration if not already configured elsewhere
# This is a simple way to ensure logs are outputted during development/testing.
# In a larger app, logging is usually configured centrally.
if not logging.getLogger().hasHandlers():
    logging.basicConfig(level=logging.INFO)


class ExtractedDependency(BaseModel):
    name: str
    version: Optional[str] = None
    type: Optional[str] = Field(
        None, description="e.g., 'OS', 'language', 'library', 'tool'"
    )


class ExtractedStep(BaseModel):
    description: str
    command: Optional[str] = None
    type: str = Field(
        ..., description="e.g., 'download', 'configure', 'build', 'run', 'verify'"
    )


class ExtractedConfiguration(BaseModel):
    parameter: str
    default_value: Optional[Any] = None
    description: Optional[str] = None
    file_path: Optional[str] = None


class ExtractedContent(BaseModel):
    tool_name: Optional[str] = None
    tool_version: Optional[str] = None
    source_url: HttpUrl
    quickstart_title: Optional[str] = None
    dependencies: List[ExtractedDependency] = []
    configurations: List[ExtractedConfiguration] = []
    setup_steps: List[ExtractedStep] = []
    docker_image: Optional[str] = None  # If a primary Docker image is identified
    docker_run_command: Optional[str] = None  # A specific run command if found
    docker_compose_snippet: Optional[str] = None  # If a compose file snippet is found
    raw_text_summary: Optional[str] = Field(
        None, description="A brief summary if generated by AI"
    )
    # Could add more fields like 'ports_to_expose', 'volumes_to_mount' etc.
    # 'error_message' could also be a field if extraction fails partially or fully
    extraction_metadata: Dict[str, Any] = Field(
        default_factory=dict, description="e.g., AI model used, confidence"
    )


class ContentExtractor(ABC):
    """
    Abstract base class for content extraction services.
    Implementations will use different strategies (e.g., specific AI models, regex, etc.)
    to parse HTML content from a quickstart document.
    """

    @abstractmethod
    async def extract(self, html_content: str, url: HttpUrl) -> ExtractedContent:
        """
        Extracts structured information from the given HTML content of a quickstart document.

        Args:
            html_content: The raw HTML string of the quickstart page.
            url: The original URL from which the content was fetched.

        Returns:
            An ExtractedContent object containing the parsed information.
            If extraction fails or partially fails, relevant fields might be None or empty,
            and 'extraction_metadata' might contain error details.
        """
        pass


# --- Mock Implementation ---
class MockContentExtractor(ContentExtractor):
    async def extract(self, html_content: str, url: HttpUrl) -> ExtractedContent:
        logger = logging.getLogger(__name__)
        logger.info(f"MockContentExtractor processing URL: {url}")

        tool_name = None
        docker_run_command = None
        dependencies = []
        docker_compose_snippet = None
        setup_steps = []
        extraction_metadata = {}

        # Simple heuristic (as was in app/main.py initially)
        if "nginx" in html_content.lower():
            tool_name = "Nginx (mock extracted)"
            docker_run_command = (
                "docker run -d -p 8080:80 --name my-nginx nginx # (mock extracted)"
            )
            dependencies.append(ExtractedDependency(name="Docker", type="tool"))
            setup_steps.append(
                ExtractedStep(
                    description="Pull Nginx Docker image",
                    command="docker pull nginx",
                    type="download",
                )
            )
            setup_steps.append(
                ExtractedStep(
                    description="Run Nginx Docker container",
                    command=docker_run_command,
                    type="run",
                )
            )
            # Mock Docker Compose for Nginx
            docker_compose_snippet = """version: '3.8'
services:
  nginx-mock:
    image: nginx
    ports:
      - "8080:80"
    restart: unless-stopped"""
            extraction_metadata = {"source": "MockExtractor - Nginx heuristic"}
        else:
            extraction_metadata = {
                "source": "MockExtractor - No specific tool recognized"
            }
            setup_steps.append(
                ExtractedStep(
                    description="No specific tool recognized by mock extractor.",
                    type="info",
                )
            )

        return ExtractedContent(
            source_url=url,
            tool_name=tool_name,
            docker_run_command=docker_run_command,
            dependencies=dependencies,
            setup_steps=setup_steps,
            docker_compose_snippet=docker_compose_snippet,
            extraction_metadata=extraction_metadata,
        )


# --- No actual AI implementation in this MVP phase ---
# Future implementations would look like:
# class GeminiExtractor(ContentExtractor):
#     async def extract(self, html_content: str, url: HttpUrl) -> ExtractedContent:
#         # ... logic to call Gemini API, parse response, map to ExtractedContent ...
#         pass

# class GptExtractor(ContentExtractor):
#     async def extract(self, html_content: str, url: HttpUrl) -> ExtractedContent:
#         # ... logic to call GPT API ...
#         pass
